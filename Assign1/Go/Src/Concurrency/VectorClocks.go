package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

var vectorClock []chan []int
var finished []chan bool
var finalResult []chan []int
var numProcesses, doneProcesses int
var lock sync.Mutex

func process(num int) {
	
	var sendChan = make(chan int, 10)
	var ProcessTS = make([]int, numProcesses)
	go clockManager(finished[num], vectorClock[num], ProcessTS, sendChan, num)

	for i := 0; i < rand.Intn(10); i++ {
		//should wait to see the correct print sequence.
		if rand.Intn(10)%2 == 0 {
			//fmt.Printf("Internal event generated by process %d\n", num)
			vectorClock[num] <- []int{-1}
		} else {
			//fmt.Printf("Process %d vector %d\n",num, ProcessTS)
			for dest := 0; dest < numProcesses; dest++ {
				if dest != num {
					sendChan <- dest
					//fmt.Printf("Process %d send message to process %d\n", num, dest)
				}
			}
		}
	}
	lock.Lock()
	doneProcesses++
	lock.Unlock()
	if doneProcesses == numProcesses {
		time.Sleep(time.Second * 1)
		for k := 0; k < numProcesses; k++ {
			finished[k] <- true
		}
		//fmt.Println("All processes finished")
	}
}

func clockManager(finished chan bool, receiveVectorChannels chan []int, ProcessTS []int,sendChan chan int, num int) {
	for {
		select {
		case vec := <-receiveVectorChannels:
			//sychronize the other process's tm
			ProcessTS[num]++
			if vec[0] != -1 {    //if internal event, just increment 1
				fmt.Printf("*****Receive Process %d local vector clock change to %d \n", num, ProcessTS)
				fmt.Printf("*****Process %d receive update vector clock %d\n", num, vec)
				for i := 0; i < numProcesses; i++ {
					if vec[i] > ProcessTS[i] {
						ProcessTS[i] = vec[i]
					}
				}
			}else{
				fmt.Printf("------Process %d generate internal message------\n", num)
				fmt.Printf("*****Process %d local vector clock %d after internal event\n", num, ProcessTS)
			}
			fmt.Printf("#####Process %d 's updated vector clock %d\n", num, ProcessTS)
		case dest := <-sendChan:
			//Receiving a signal
			//increment and send a vector timestamp
			fmt.Printf("------Process %d send message to process %d------\n", num, dest)
			ProcessTS[num]++
			fmt.Printf("*****Sending Process %d local vector clock %d\n", num, ProcessTS)
			vectorClock[dest] <- ProcessTS
		case <-finished:
			finalResult[num] <- ProcessTS
			break
		}
	}
}

func main() {

	numProcesses = 3  //create n processes
	doneProcesses = 0
	vectorClock = make([]chan []int, numProcesses)
	finished = make([]chan bool, numProcesses)
	finalResult = make([]chan []int, numProcesses)

	for i := 0; i < numProcesses; i++ {
		vectorClock[i] = make(chan []int, 10*numProcesses)
		finished[i] = make(chan bool, numProcesses)
		finalResult[i] = make(chan []int, numProcesses)
	}
	for k := 0; k < numProcesses; k++ {
		go process(k)
	}
	for p := 0; p < numProcesses; p++ {
		fmt.Printf("Vector Clock for process %d: %v\n", p, <-finalResult[p])
	}
}
